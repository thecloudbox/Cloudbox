import type { Incident, AutoGeneratedRunbook, RunbookStep } from "./types"

/**
 * Auto-Generated Runbook Engine
 * Market gap: Learns from incidents to create automated playbooks
 */
export class RunbookGenerator {
  private runbooks: Map<string, AutoGeneratedRunbook> = new Map()
  private incidentPatterns: Map<string, Incident[]> = new Map()

  /**
   * Learn from incident and generate or update runbook
   */
  learnFromIncident(incident: Incident) {
    const pattern = this.extractPattern(incident)
    const incidents = this.incidentPatterns.get(pattern) || []
    incidents.push(incident)
    this.incidentPatterns.set(pattern, incidents)

    // Generate runbook after seeing pattern 3+ times
    if (incidents.length >= 3 && !this.runbooks.has(pattern)) {
      this.generateRunbook(pattern, incidents)
    }
  }

  private extractPattern(incident: Incident): string {
    // Extract pattern from incident characteristics
    const service = incident.affectedServices[0] || "unknown"
    const severity = incident.severity

    if (incident.description.includes("memory")) return `${service}_memory_issue`
    if (incident.description.includes("cpu")) return `${service}_cpu_spike`
    if (incident.description.includes("disk")) return `${service}_disk_full`
    if (incident.description.includes("latency")) return `${service}_high_latency`

    return `${service}_${severity}_incident`
  }

  private generateRunbook(pattern: string, incidents: Incident[]) {
    const steps: RunbookStep[] = []

    // Analyze successful remediations from past incidents
    const resolvedIncidents = incidents.filter((i) => i.status === "resolved" || i.status === "auto-resolved")

    if (pattern.includes("memory")) {
      steps.push({
        order: 1,
        action: "Check memory usage",
        command: "free -h && ps aux --sort=-%mem | head -10",
        expectedOutcome: "Identify process consuming excessive memory",
        failureHandling: "Escalate to on-call engineer",
      })
      steps.push({
        order: 2,
        action: "Restart service with memory leak",
        command: "systemctl restart <service>",
        expectedOutcome: "Memory usage returns to normal levels",
        failureHandling: "Check for application memory leaks in code",
      })
    } else if (pattern.includes("cpu")) {
      steps.push({
        order: 1,
        action: "Identify high CPU processes",
        command: "top -b -n 1 | head -20",
        expectedOutcome: "Locate CPU-intensive process",
        failureHandling: "Enable CPU profiling for detailed analysis",
      })
      steps.push({
        order: 2,
        action: "Scale up instances",
        command: "kubectl scale deployment <name> --replicas=5",
        expectedOutcome: "CPU load distributed across more instances",
        failureHandling: "Check for infinite loops or inefficient code",
      })
    } else if (pattern.includes("latency")) {
      steps.push({
        order: 1,
        action: "Check database query performance",
        command: "EXPLAIN ANALYZE <slow_query>",
        expectedOutcome: "Identify slow query or missing index",
        failureHandling: "Enable query caching or add indexes",
      })
      steps.push({
        order: 2,
        action: "Verify network connectivity",
        command: "ping -c 5 <dependency> && traceroute <dependency>",
        expectedOutcome: "Confirm network path is healthy",
        failureHandling: "Check firewall rules and security groups",
      })
    }

    const avgResolutionTime = resolvedIncidents.reduce((sum, i) => sum + (i.mttr || 0), 0) / resolvedIncidents.length

    const runbook: AutoGeneratedRunbook = {
      id: `runbook_${pattern}`,
      title: `Automated Runbook: ${pattern.replace(/_/g, " ")}`,
      triggeredBy: pattern,
      steps,
      successRate: (resolvedIncidents.length / incidents.length) * 100,
      timesExecuted: incidents.length,
      avgResolutionTime,
      lastUpdated: Date.now(),
    }

    this.runbooks.set(pattern, runbook)
  }

  getRunbooks(): AutoGeneratedRunbook[] {
    return Array.from(this.runbooks.values())
  }

  getRunbookForIncident(incident: Incident): AutoGeneratedRunbook | undefined {
    const pattern = this.extractPattern(incident)
    return this.runbooks.get(pattern)
  }
}
